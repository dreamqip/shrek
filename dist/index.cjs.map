{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import { Address, Contract, Transaction } from \"@ton/core\";\nimport { Blockchain, SandboxContract } from \"@ton/sandbox\";\n\nexport class Logger {\n  private blockchain: Blockchain;\n  private contractLabels: Map<string, string>;\n\n  constructor(blockchain: Blockchain) {\n    this.blockchain = blockchain;\n    this.contractLabels = new Map<string, string>();\n  }\n\n  /**\n   * Adds a contract label for easy identification.\n   * @param contract The contract or address to label.\n   * @param label The label to associate with the contract.\n   */\n  addContract<F extends Contract>(\n    contract: SandboxContract<F> | Address | string,\n    label: string,\n  ): void {\n    const address = this.getAddressString(contract);\n\n    if (this.contractLabels.has(address)) {\n      throw new Error(\n        `The '${address}' contract already has a '${label}' label!`,\n      );\n    }\n\n    this.contractLabels.set(address, label);\n  }\n\n  /**\n   * Retrieves the label for a given contract address.\n   * @param address The address of the contract.\n   * @returns The label associated with the address or a shortened version of the address.\n   */\n  getContractLabel(address: Address): string {\n    return this.contractLabels.get(address.toString()) ||\n      shortenString(address.toString());\n  }\n\n  /**\n   * Retrieves the balance for a given contract address.\n   * @param address The address of the contract.\n   * @returns The balance associated with the address.\n   */\n  async getContractBalance(address: Address): Promise<bigint> {\n    try {\n      const contract = await this.blockchain.getContract(address);\n      return contract.balance;\n    } catch (error) {\n      console.error(\"Error fetching contract balance:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Logs all contract balances.\n   */\n  async logContracts(): Promise<void> {\n    const data = await this.getContractData();\n    console.table(data);\n  }\n\n  /**\n   * Logs transactions to the console in a table format.\n   * @param transactions The list of transactions to log.\n   * @param info Optional info to log before the transactions.\n   */\n  async logTransactions(\n    transactions: Transaction[],\n    info?: string,\n  ): Promise<void> {\n    if (info) {\n      console.info(info);\n    }\n\n    const formattedTransactions = await Promise.all(\n      transactions.map((tx) => this.formatTransaction(tx)),\n    );\n    console.table(formattedTransactions.filter((tx) => tx !== undefined));\n  }\n\n  /**\n   * Formats a transaction into a readable object.\n   * @param tx The transaction to format.\n   * @returns A formatted transaction object or undefined if not applicable.\n   */\n  private async formatTransaction(\n    tx: Transaction,\n  ): Promise<object | undefined> {\n    if (tx.description.type !== \"generic\") {\n      return undefined;\n    }\n\n    const body = tx.inMessage?.info.type === \"internal\"\n      ? tx.inMessage.body?.beginParse()\n      : undefined;\n    const op = body && body.remainingBits >= 32\n      ? body.preloadUint(32)\n      : \"0gR33n0gr\";\n\n    const source = tx.inMessage?.info.src;\n    let sourceLabel = \"Shrek\";\n\n    if (source && Address.isAddress(source)) {\n      sourceLabel = this.getContractLabel(source);\n    }\n\n    const destination = tx.inMessage?.info.dest;\n    let destinationLabel = \"Donkey\";\n\n    if (destination && Address.isAddress(destination)) {\n      destinationLabel = this.getContractLabel(destination);\n    }\n\n    return {\n      \"Source\": sourceLabel,\n      \"Destination\": destinationLabel,\n      \"Type\": tx.inMessage?.info.type,\n      \"Opcode\": typeof op === \"number\" ? \"0x\" + op.toString(16) : op,\n      \"Incoming Value\": formatCoins(\n        tx.inMessage?.info.type === \"internal\"\n          ? tx.inMessage.info.value.coins\n          : undefined,\n      ),\n      \"Outgoing Value\": tx.outMessages.values().length == 0\n        ? \"No coins!\"\n        : tx.outMessages.values().filter((msg) => msg.info.type === \"internal\")\n          // @ts-expect-error\n          .map((msg) => formatCoins(msg.info.value.coins)),\n      \"Total Fees\": formatCoins(tx.totalFees.coins),\n      \"Outgoing Actions Count\": tx.description.actionPhase?.totalActions ??\n        \"No actions here?\",\n      \"Exit Code\": tx.description.computePhase.type === \"vm\"\n        ? tx.description.computePhase.exitCode\n        : \"Ogres have layers?\",\n    };\n  }\n\n  /**\n   * Gets the address string from a contract, address, or string.\n   * @param contract The contract or address.\n   * @returns The address as a string.\n   */\n  private getAddressString<F extends Contract>(\n    contract: SandboxContract<F> | Address | string,\n  ): string {\n    if (typeof contract === \"object\" && \"address\" in contract) {\n      return (contract as SandboxContract<F>).address.toString();\n    } else if (typeof contract === \"string\") {\n      return contract;\n    } else {\n      return contract.toString();\n    }\n  }\n\n  /**\n   * Retrieves formatted contract data.\n   * @returns The formatted contract data array.\n   */\n  private async getContractData(): Promise<\n    { Contract: string; \"Contract Balance\": string }[]\n  > {\n    const data: { \"Contract\": string; \"Contract Balance\": string }[] = [];\n\n    for (const [addressAsString, label] of this.contractLabels) {\n      const address = Address.parse(addressAsString);\n      const balance = await this.getContractBalance(address);\n\n      data.push({\n        \"Contract\": label,\n        \"Contract Balance\": formatCoins(balance),\n      });\n    }\n\n    return data;\n  }\n}\n\n// BEGIN HELPERS\n\n/**\n * Shortens a string to the first and last 4 characters, separated by ellipses.\n * @param str The string to shorten.\n * @returns The shortened string.\n */\nfunction shortenString(str: string): string {\n  return str.length <= 8 ? str : `${str.slice(0, 4)}...${str.slice(-4)}`;\n}\n\nconst decimalCount = 9;\nconst decimal = pow10(decimalCount);\n\n/**\n * Calculates 10 raised to the power of n.\n * @param n The exponent.\n * @returns The value of 10^n as a bigint.\n */\nfunction pow10(n: number): bigint {\n  let v = 1n;\n  for (let i = 0; i < n; i++) {\n    v *= 10n;\n  }\n  return v;\n}\n\n/**\n * Formats a coin value to a readable string with a given precision.\n * @param value The coin value to format.\n * @param precision The number of decimal places to display.\n * @returns The formatted coin value as a string.\n */\nfunction formatCoinsPure(value: bigint, precision = 6): string {\n  let whole = value / decimal;\n  let frac = value % decimal;\n  const precisionDecimal = pow10(decimalCount - precision);\n\n  if (frac % precisionDecimal > 0n) {\n    frac += precisionDecimal;\n    if (frac >= decimal) {\n      frac -= decimal;\n      whole += 1n;\n    }\n  }\n  frac /= precisionDecimal;\n\n  return `${whole.toString()}${\n    frac !== 0n\n      ? \".\" + frac.toString().padStart(precision, \"0\").replace(/0+$/, \"\")\n      : \"\"\n  }`;\n}\n\n/**\n * Formats a coin value to a readable string, handling undefined or null values.\n * @param value The coin value to format.\n * @param precision The number of decimal places to display.\n * @returns The formatted coin value as a string or \"N/A\" if value is undefined or null.\n */\nexport function formatCoins(\n  value: bigint | undefined | null,\n  precision = 6,\n): string {\n  return value === undefined || value === null\n    ? \"âˆž\"\n    : formatCoinsPure(value, precision);\n}\n\n// END HELPERS\n"],"mappings":"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","names":[]}